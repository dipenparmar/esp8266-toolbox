#!/usr/bin/env python

from   datetime import datetime
import socket
from   time     import sleep

def encode_remlen(remlen):
    if remlen <= 127:
        return chr(remlen)

    elif remlen <= 127 + 127*128:
        return chr(0x80 | (remlen       & 0x7f)) + \
               chr(       (remlen >> 7) & 0x7f)

    elif remlen <= 127 + 127*128 + 127*128**2:
        return chr(0x80 | ( remlen         & 0x7f)) + \
               chr(0x80 | ((remlen >> 7)   & 0x7f)) + \
               chr(       ((remlen >> 7*2) & 0x7f))

    elif remlen <= 127 + 127*128 + 127*128**2 + 127*128**3:
        return chr(0x80 | ( remlen         & 0x7f)) + \
               chr(0x80 | ((remlen >> 7)   & 0x7f)) + \
               chr(0x80 | ((remlen >> 7*2) & 0x7f)) + \
               chr(       ((remlen >> 7*3) & 0x7f))

    else:
        assert False

def decode_remlen(packet):
    if ord(packet[1]) & 0x80 == 0:
        return 1, ord(packet[1])

    elif ord(packet[2]) & 0x80 == 0:
        return 2, (ord(packet[1]) & 0x7f) + ord(packet[2])*128

    elif ord(packet[3]) & 0x80 == 0:
        return 3, (ord(packet[1]) & 0x7f) + ord(packet[2])*128 + \
                                            ord(packet[3])*128**2

    elif ord(packet[4]) & 0x80 == 0:
        return 4, (ord(packet[1]) & 0x7f) + ord(packet[2])*128    + \
                                            ord(packet[3])*128**2 + \
                                            ord(packet[4])*128**3

    else:
        assert False

def connect_packet():
    #user, passwd = 'guest', 'guest'
    user, passwd = None, None
    useauth = user is not None and passwd is not None

    # NB Client ids must be unique, the RabbitMQ MQTT impl. will drop the (old) duplicate
    #    Unique trailing identifier to be generated from the 32-bit system_get_chip_id()
    #    Only alphanumerics are required to be supported by servers according to the standard
    clientid = 'pyesp000ef1e8'
    assert 0 < len(clientid) and len(clientid) <= 23

    remlen = 10 + 2+len(clientid)
    if useauth:
        remlen += 2+len(user) + 2+len(passwd)

    encremlen = encode_remlen(remlen)

    #
    # Fixed header
    #

    packet = '\x10' + encremlen

    #
    # Variable header
    #

    packet += '\x00\x04' + 'MQTT'

    # MQTT 3.1.1
    packet += '\x04'

    #  Clean Session = 1
    #      Will Flag = 0
    #       Will QoS = 0
    #    Will Retain = 0
    #  Password Flag = ?
    # User Name Flag = ?
    b = 0x02
    if useauth:
        b |= 0xc0
    packet += chr(b)

    keepalive = 60
    assert -1 < keepalive and keepalive < 2**16
    packet += chr((keepalive>>8) & 0x0ff) + chr(keepalive & 0x0ff)

    #
    # Payload
    #

    packet += chr((len(clientid)>>8) & 0x0ff) + chr(len(clientid) & 0x0ff)
    packet += clientid

    if useauth:
        packet += chr((len(user)>>8) & 0x0ff) + chr(len(user) & 0x0ff)
        packet += user

        packet += chr((len(passwd)>>8) & 0x0ff) + chr(len(passwd) & 0x0ff)
        packet += passwd

    assert len(packet) == 1 + len(encremlen) + 10 + 2+len(clientid) + \
               (2+len(user) + 2+len(passwd) if useauth else 0)

    return packet

def connectack_packet(packet):
    contents = {}

    #
    # Fixed header
    #

    contents['control packet type'] = (ord(packet[0]) >> 4) & 0x0f

    nbytes, contents['remaining length'] = decode_remlen(packet)

    #
    # Variable header
    #

    contents['session present']     = ord(packet[1+nbytes]) & 0x01
    contents['connect return code'] = ord(packet[2+nbytes])

    assert contents['control packet type'] == 2
    assert    contents['remaining length'] == 2
    assert     contents['session present'] == 0

    # 0 - Connection Accepted
    # 1 - Connection Refused, Unacceptable protocol version
    # 2 - Connection Refused, Identifier rejected
    # 3 - Connection Refused, Server unavailable
    # 4 - Connection Refused, Bad user name or password
    # 5 - Connection Refused, Not authorized

    return contents['connect return code']

def pingreq_packet():
    #
    # Fixed header
    #

    packet = '\xc0\x00'

    return packet

def pingresp_packet(packet):
    contents = {}

    #
    # Fixed header
    #

    contents['control packet type'] = (ord(packet[0]) >> 4) & 0x0f
    contents['remaining length']    = decode_remlen(packet)

    assert contents == {'control packet type': 0xd,
                           'remaining length': 0}

def publish_packet(data, topic='test'):
    assert 0 < len(topic)

    remlen    = 2+len(topic) + len(data)
    encremlen = encode_remlen(remlen)

    #
    # Fixed header
    #

    #  DUP flag = 0
    # QoS level = 0
    #    RETAIN = 0
    packet = '\x30'

    packet += encremlen

    #
    # Variable header
    #

    packet += chr((len(topic)>>8) & 0x0ff) + chr(len(topic) & 0x0ff)
    packet += topic

    # Packet identifier only for QoS levels 1 and 2

    #
    # Payload
    #

    packet += data

    return packet

if __name__ == '__main__':
    def send(sock, data):
        sent = 0
        while sent < len(data):
            n = sock.send(data[sent:])
            assert n > 0
            sent += n
    
    def recv(sock, n):
        retval = ''
        recvd  = 0
        while recvd < n:
            data = sock.recv(min(n - recvd, 1024))
            assert len(data) > 0
            retval += data
            recvd  += len(data)
        return retval

    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect(('127.0.0.1', 1883))

    #
    # Connect
    #

    send(sock, connect_packet())
    print '>>> CONNECT'

    packet = recv(sock, 2)
    # Should refactor to support larger packets (via decode_remlen)
    assert ord(packet[1]) & 0x80 == 0
    packet += recv(sock, ord(packet[1]))
    assert connectack_packet(packet) == 0
    print '<<< CONNECTACK'

    # FIXME STOPPED
    #
    #send(sock, subscribe_packet())
    #print '>>> SUBSCRIBE'
    #
    #packet  = recv(sock, 2)
    #packet += recv(sock, ord(packet[1]))
    #assert suback_packet(packet) == 0
    #print '<<< SUBACK'

    while True:
        #
        # Publish
        #

        payload = 'python ' + datetime.now().strftime('%Y%m%d%H%M%S')
        send(sock, publish_packet(payload))
        print '>>> PUBLISH "%s"' % payload
        # No response for QoS level 0

        #
        # Ping request/reply
        #
        # Only necessary if the publish period is shorter than the keepalive
        #

        #send(sock, pingreq_packet())
        #packet = recv(sock, 2)
        # Should refactor to support larger packets (via decode_remlen)
        #assert ord(packet[1]) & 0x80 == 0
        #packet += recv(sock, ord(packet[1]))
        #print '>>> PINGREQ'

        #pingresp_packet(packet)
        #print '<<< PINGRESP'

        sleep(10)
